# 查找算法

## 顺序查找

**介绍：**

​	顺序查找属于**无序查找**算法。

**时间复杂度分析：**

​	O(n)

**代码实现：**

~~~js
function orderFind(arr, n) {
    let len = arr.length;
    for(let i = 0; i < len; i ++) {
        if(arr[i] == n) {
            return i;
        }
    }
    return -1;
}
~~~

**适用范围：**

适用于存储结构为顺序存储或链接存储的线性表。

## 分块查找

又称索引顺序查找，它是顺序查找的一种改进方法。

**算法思想：**

将数据划分为m块儿（类似于桶排序的思想），每块中的节点不必有序，但块与块之间必须“按块有序”，即第一块中任意元素都必须小于第二块儿中任意元素。然后找到每一块中的最大值，把最大值放一个数组中，用二分查找或者顺序查找，找到精确的哪一块，然后在已确定的块中用顺序法进行查找。

## 二分查找

**介绍：**

也称折半查找，属于**有序的查找算法**。

前提是元素必须是有序的。

**时间复杂度分析：**

​	O(logn)

**代码实现：**

~~~js
let arr = [1,2,3,4,5,6,7,8,9], n = 5;
function BinarySearch (arr, n) {
    let len = arr.length, low, high, mid; 
    for(let i = 0; i < len; i ++) {
        low = 0, high = len - 1;
        while(low < high) {
            mid = parseInt((low + high) / 2);
            if(arr[mid] == n) {
                return mid;
            } else if(arr[mid] > n) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
console.log(BinarySearch(arr,n));
~~~

**适用范围：**

适用于有序的静态查找表的查找；

对于需要频繁执行插入和删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。	——《大话数据结构》

## 差值查找（  ！）

**情景带入：:happy:**

是否有这样一种情况，如果数组是从1到100的100个数字，让你查找5，那么人为的思想肯定是从前往后找。如果用二分法查找呢？50,25,12,6,3,4,5这样一个顺序来找，是不是就有点憨憨，哈哈哈​ :happy:

**介绍：**

二分法查找点的计算：

mid = low + 1/2 * (hide -  low);

通过类比，我们可以查找的点改进如下：

**mid = low + (n - arr[low]) / (arr[high] - arr[low]) * (high - low);(这里不理解)**

也就是将上述的1/2改为字适应的值，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近要查找的数值n，这样也就间接的减少了查找次数。

**时间复杂度分析：**

查找成功或者失败的时间复杂度均为**O(loglogn)**。

**代码实现：**

~~~js
let arr = [1,3,4,6,7,9,11,13,14,15,16];
let n = 2;
function interpolationFind(arr, n) {
    let time = 0;
    let low, high, mid, len = arr.length;
    low = 0, high = len - 1;
    while(low < high) {
        console.log('比较次数：', ++ time);
        //这里的parseInt只能放这个位置，放其他位置会导致出错，亲测！
        if(low < high) {//在力扣中发现，插值查找算法不能用于数组中只有一个元素的情况，所以此情况要将mid值变为二分查找的mid值
            mid = low + parseInt((n - arr[low]) / (arr[high] - arr[low]) * (high - low));
        } else {
            mid = low + parseInt((high - low) / 2);
        }
        console.log(mid);
        // mid = low + parseInt((high - low) / 2);
        if(arr[mid] == n) {
            return mid;
        } else if (arr[mid] > n) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}

console.log('n的位置：', interpolationFind(arr, n));
~~~

**适用范围：**

对于表长较大，数据分布比较均匀的查找表来说，差值查找比二分查找性能要好的多。

反之，如果数组数据分布非常不均匀，那么差值查找未必是个合适的选择。

## 斐波那契查找（ ！）



## 树表查找（ ！）

### 二叉树查找算法

**介绍：**

先对需要排序的数据进行生成树，确保树左分支的值小于右分支的值，然后进行查找。

这种算法的查找效率很高，但是要先创建树。



**二叉查找树**（又称二叉搜索树、二叉排序树）的性质：

- 若其左子树不空，则数值小于根节点值
- 若其右子树不空，则数值大于根节点值
- 任意节点的左右子也为二叉查找树

**对齐进行中序遍历（或叫中根遍历），即可得到有序序列。**

拓展：

- 先序遍历：根-->左-->右
- 中序遍历：左-->根-->右
- 后序遍历：左-->右-->根

**时间复杂度分析：**

它和二分查找一样，插入和查找的时间复杂度均为**O(logn)**，**但在最坏的情况下仍然有O(n)的时间复杂度**，原因在于插入和删除元素的时候树并没有保持平衡，比如在下图中查找17，我们就需要进行n次操作（因为此树并不平衡）。

我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

![img](https://pic1.zhimg.com/80/v2-f28b193d1589c4cfb184d48fb2080058_hd.jpg)

### 2-3查找树

直接上图，简单明了：

![img](https://pic1.zhimg.com/80/v2-6ccac7896663c7720586999426e1dcd8_hd.jpg)

这就是2-3查找树。

**性质：**

- 如果中序遍历2-3查找树，则可以得到有序序列；
- 在一个完全平衡的2-3查找树找那个，根节点到每一个为空的节点的举例都相同。（这也是平衡树中“平衡”的概念。

**复杂度分析：**

2-3查找树的查找效率与树的高度是息息相关的。

- 最坏的情况下，也就是所有的节点都是2-node节点，查找效率为log2n
- 最好的情况下，也就是所有的节点都是3-node节点，查找效率为log3n，约等于0.631log2n.

### 红黑树

它是一种简单实现2-3树的数据结构。

红黑树具体内容参见树篇

### B树和B+树

同上，在树篇会有深入的讲解。

### 树表查找总结：

二叉查找树平均性能不错，为O(logn)，但最坏的情况下会退化为O(n)。

在二叉查找树的基础上进行优化，我们可以使用平衡查找树。

平衡查找树的2-3查找树，这种数据结构在插入图之后能够进行自平衡处理，从而保证了树的高度在一定的范围内，最坏的情况的时间复杂度也有了保证。

但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，它巧妙地使用颜色标记来替代2-3树种比较难处理的3-node节点问题。

**红黑树是一种比较高效的平衡查找树，应用非常广泛**，很多编程语言的内部实现都或多或少的采用了红黑树。

除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。

## 哈希查找（散列查找）（ ！）

**算法流程：**

1. 用给点的哈希函数构造哈希表
2. 根据选择的冲突处理方法解决地址冲突
3. 在哈希表的基础上执行哈希查找

哈希表示一个在时间和空间上做出权衡的经典例子。如果没有内存限制，可以直接将键作为数组的索引，那么所有的查找时间复杂度为（1）；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间赖在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上作出或取舍。

**复杂度：**

单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)，但是要注意我们在这之前要构建Hash表。

**使用Hash，我们付出了什么？**

Hash是一种典型的以空间换时间的算法。

比如在有一个长度为100的数组，占用了100byte的空间，那么我们需要一个固定长度的Hash表，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总空间为200byte，而且用于记录规则的表大小会根据规则，大小可能是不定的。



