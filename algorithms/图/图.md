## 图

### 图

#### 什么是图？

**图是一种非线性结构。**

**在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除了第一个和最后一个元素之外）都只有一个直接前驱和直接后继。**

**在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层的一个元素（父节点）与下一层的多个元素（子节点）相关。**

**而在图形结构中，节点之间的关系是任意的，图中任意两个元素之间都可能有关系。**



**图G由两个集合V（顶点Vertex）和E（边Edge）组成，定义G=(V,E)**



#### **无向图和有向图**

对于一个图，每条边都没有方向，则为无向图

![ds54](https://images0.cnblogs.com/blog/311549/201309/23224321-acabc2d2b2414039b8f28b3c73736377.jpg)

因此，（Vi，Vj）与（Vj，Vi）表示的是同一条边。

**无向图用小括号**。

无向图的顶点和边的集合表示为：

V（G） = {V1,V2,V3,V4,V5}；

E(G) = {（V1,V2），（V1,V4），（V2,V3），（V2,V5），（V3,V4），（V3,V5），（V4,V5）}



**有向图：**

对于一个图，每条边都有方向，则为有向图

![ds55](https://images0.cnblogs.com/blog/311549/201309/23224323-05a9dbe615be404fb1bec89e78d902ea.jpg)

因此，<Vi，Vj>与<Vj，Vi>是两条不同的边。注意，有向边又称为**弧**。

**有向图用尖括号。**

有向图的顶点和边的集合表示为：

V(G) = {V1,V2,V3}

E(G) = {<V1,V2>,<V1,V3>,<V2,V3>,<V3,V1>}



#### **无向完全图：**

具有n(n-1)/2条边的无向图称为无向完全图，**也就是任意两顶点间都有边**。

#### **有向完全图：**

具有n(n-1)条边的有向图称为有向完全图，**也就是任意两顶点间都有边**。

**顶点的度：**

对于**无向图**，**顶点的度表示为该顶点作为一个端点的边的数目**，上图无向图中V3顶点的度为D(V3)=3.

对于**有向图**，**顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度表示以该顶点为起点的出边的数目。该顶点的度等于入度与出度之和。**	比如上图有向图中V1顶点的入度为ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1) + OD(V2) = 3。

记住，无论是无向图还是有向图，顶点数n，边数e和顶点的度数D有如下关系：

![clip_image002](https://images0.cnblogs.com/blog/311549/201309/23224324-bf0604640183442089367a4e9a8e4d98.gif)

因此，就拿有向图的图举例，由公式可得到图G的边数e = (D(V1) + D(V2) + D(V3))/2 = （3+2+3）/ 2=4

**路径、路径长度和回路：**

路径，比如在无向图G中，存在一个顶点序列Vp,Vi1,Vi2,Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…,(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。

路径长度，是指一条路径上经过的边的数量。

回路，指一条路径的起点和终点为同一个顶点。



#### 连通图和强连通图

**连通图（无向图）：**

是指图G中任意两个顶点都连通。

下图是一个非连通图：

![ds56](https://images0.cnblogs.com/blog/311549/201309/23224326-f097843b27124d1397e5ef24ba59788a.jpg)

**强连通图（有向图）：**

是对于有向图而言任意两点都连通。

#### 网

带权值的连通图称为网。

![ds57](https://images0.cnblogs.com/blog/311549/201309/23224329-5c5bb81883bf49ca8f4f030166823dce.jpg)

#### 有权图和无权图

![图片描述](https://segmentfault.com/img/bVTNKF?w=1406&h=616)

![图片描述](https://segmentfault.com/img/bVTNKN?w=1276&h=643)

#### 用图对现实中的系统建模

> 可以用图对现实中许多系统建模。

比如对交通流量建模，顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。

**任何运输系统都可以用图来建模。**比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。

包含局域网和广域网（如互联网）在内的计算机网络，同样经常用图来建模。

另一个可以用图来建模的实现系统是消费市场，顶点可以用来表示供应商和消费者。

#### 构建图

用邻接矩阵的方式构建图：
完整的Graph类：

~~~js

~~~









### 图的存储 

#### 邻接矩阵 

原理就是用**两个数组**，一个保存顶点集V，一个保存边集E。

如图所示：

![ds58](https://images0.cnblogs.com/blog/311549/201309/23224332-2a1470a4939649d2ac2ab0631a197e54.jpg)







#### 邻接表 

邻接表是图的一种**链式存储**结构。这种结构类似树的孩子链表。

**对于图G中每个顶点Vi，把所有临接Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。**



**图的两种遍历方法：**

- 深度优先遍历
  - 

![ds59](https://images0.cnblogs.com/blog/311549/201309/23224338-cdb3d0624b954309895c8df7d4888adc.jpg)

若采用邻接矩存储，则时间复杂度为O(n²)；若采用邻接表存储，则时间复杂度为O(n+e)

- 广度优先遍历
  - ![ds60](https://images0.cnblogs.com/blog/311549/201309/23224348-ea0a1240ea0349e8a79eae6e3f811336.jpg)

若采用邻接矩阵存储，时间复杂度为O(n²)；若采用邻接表存储，时间复杂度为O(n+e)。

### 关键路径





### 最小生成树

什么是生成树呢？用一句话简单概括就是：**生成树就是将图中所有的顶点以最少的边连通的子图**。

![ds61](https://images0.cnblogs.com/blog/311549/201309/23224400-2f02f05faf3946a9a49dadcbfa618876.jpg)

**所谓最小生成树，就是权值之和最小的 生成树。**

 比如上图中的两个生成树，生成树1和生成树2，生成树1的权值和为：12，生成树2的权值为：14，我们可以证明图(h)生成树1就是图(g)的最小生成树。 

**那么如何构造最小生成树呢？可以使用普利姆算法。**



### 最短路径

求最短路径，也就是求最短路径长度。下面是一个带权值的有向图，表中列出了V1到各顶点的最短路径长度。

![ds62](https://images0.cnblogs.com/blog/311549/201309/24220111-7b0854dcf7c54aa3b7fbd9d587a86a83.jpg)



| 起点 | 最短路径    | 终点 | 路径长度 |
| ---- | ----------- | ---- | -------- |
| V1   | V1,V3,V2    | V2   | 5        |
| V1   | V1,V3       | V3   | 3        |
| V1   | V1,V3,V2,V4 | V4   | 10       |
| V1   | V1,V3,V5    | V5   | 18       |

**那么如何求带权有向图的最短路径长度呢？可以用迪杰特斯拉算法。**



> 图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径.
> 考虑下面的例子：

假期中，你将在两个星期的时间里游历10个旅游城市，去那里最富盛名的景点（1 个），你希望通过最短路径算法，找出开车游历10个城市行驶的最小历程数。
另一个最短路径问题涉及创建一个计算机网络时的开销，其中包括两台电脑之间传递数据的时间，或者两台电脑建立和维护连接的成本。
最短路径算法可以帮助确定构建此网络的最有效方法。

### 拓扑排序 

拓扑排序是有向无环图（DAG）的所有顶点的线性序列。

该序列必须满足下列两个条件：

- 每个顶点只能出现一次
- 若存在一条从顶点A到顶点B的路径，那么在序列中A在B的前面。

**只有有向无环图（DAG）才有拓扑排序！**

![图片描述](https://segmentfault.com/img/bVTB6h?w=335&h=270)

上图是一个DAG图，那么如何写它的拓扑排序呢？

这里有一个比较常见的方法：

1. **从DAG图中找到一个没有前驱（即入度为0）的顶点，并输出**
2. **从图中删除该顶点，和以该顶点为起点的有向边**
3. 重复1和2直到当前DAG图为空，或当前不存在无前驱的顶点为止。后一种情况说明该有向图中必然有环。

![图片描述](https://segmentfault.com/img/bVTCas?w=544&h=350)

于是得到拓扑排序的结果：1,2,4,3,5

**通常，一个有向无环图会有一个或多个拓扑排序序列。**



#### 拓扑排序的应用

**拓扑排序经常用来“排序”具有依赖关系的任务。**

它与BFS类似，不同的是，它不会直接输出已访问顶点，而是访问当前顶点邻接表中所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。

举个例子：

![图片描述](https://segmentfault.com/img/bVTCum?w=289&h=178)

其拓扑排序可以是：

> 1,4,2,3,5,7,9,10,12,11,6,8

也可以是：

> 9,10,11,6,1,2,3,4,5,7,8,12

再比如，如果用一个DAG图表示一个工程，其中每个顶点表示工程的一个任务，用有向边<A,B>表示在做B任务之前必须要完成任务A。	故在这个过程中，任意两个任务，要么具有明确的先后关系，要么没有关系，绝对不存在互相矛盾的关系（即环路）。





