## 树

树是n个节点的有限集。

**普通的树：**

![img](https://upload-images.jianshu.io/upload_images/7043118-2c735a2733887dc3.png?imageMogr2/auto-orient/strip|imageView2/2/w/502/format/webp)

**节点的度：**

![img](https://upload-images.jianshu.io/upload_images/7043118-cfa7c45bb8f1e332.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)

**节点的关系：**

孩子节点、双亲结点、兄弟节点。

**节点层次：**

![img](https://upload-images.jianshu.io/upload_images/7043118-7c9318a6f5c1349d.png?imageMogr2/auto-orient/strip|imageView2/2/w/652/format/webp)

**树的深度：**

树中节点的最大层次数即树的深度。

### 二叉树

![img](https://upload-images.jianshu.io/upload_images/7043118-797eb7ba417745b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/455/format/webp)

**二叉树的特点：**

- 每个节点最多有两棵子树
- 左子树和右子树是有顺序的，不能随意颠倒
- 即使某节点只有一棵子树，也要分左、右子树

**二叉树的性质：**

- 二叉树的第i层最多有 2**(i-1)个节点
- 二叉树深度为k，那么最多有2**(k) - 1个节点
- 在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n] + 1，其中[log2n]向下取整
- 若对有n个节点的完全二叉树从上到下、从左到右依次由1~n编号，则对任意一个i节点有如下性质：
  - 若i = 1，则为根节点，无双亲；若i ！= 1，则编号i/2为其双亲节点
  - 若2i > n，则该节点无左孩子，否则，编号为2i的节点为其左孩子节点
  - 若2i + 1 > n，则该节点无右孩子，否则，编号为2i + 1的节点为其右孩子节点

**斜树：**

- 所有的节点都只有左节点的二叉树叫左斜树
- 所有的节点都只有右节点的二叉树叫右斜树
- 二者统称为斜树

![img](https://upload-images.jianshu.io/upload_images/7043118-a512316455261ec7.png?imageMogr2/auto-orient/strip|imageView2/2/w/373/format/webp)

![img](https://upload-images.jianshu.io/upload_images/7043118-352190ff8558efcb.png?imageMogr2/auto-orient/strip|imageView2/2/w/342/format/webp)

**完全二叉树：**

![img](https://upload-images.jianshu.io/upload_images/7043118-132fd0379f34bcc1.png?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

**特点：**

- 叶子结点只能出现在最底层和次底层
- 最底层的叶子结点集中在左部
- 倒数第二层如果有叶子结点，则一定在右部
- 如果某节点的度为1，则它一定只有左孩子，没有右孩子
- 同样节点数目的二叉树，完全二叉树层数最小

**满二叉树一定是完全二叉树，反过来则不一定成立**



**满二叉树：**

所有分支节点都有左子树和右子树，而且所有叶子结点都在同一层上的二叉树叫满二叉树

**满二叉树的特点：**

- 叶子结点只能出现在最底层，出现在其它层就不可能达到平衡
- 非叶子结点的度一定为2
- 在同样深度的二叉树中，满二叉树的节点个数最多，叶子结点个数最多

![img](https://upload-images.jianshu.io/upload_images/7043118-c7a557dda4ffc7da.png?imageMogr2/auto-orient/strip|imageView2/2/w/392/format/webp)

**二叉树的存储结构：**

- 顺序存储
  - 二叉树的顺序存储结构就是使用一维数组来存储二叉树中的节点，并且节点的存储位置，就是数组的下标

![img](https://upload-images.jianshu.io/upload_images/7043118-3293242769696303.png?imageMogr2/auto-orient/strip|imageView2/2/w/441/format/webp)

上图的完全二叉树采用顺序存储的方式，如下图：

![img](https://upload-images.jianshu.io/upload_images/7043118-e916580c061a1139.png?imageMogr2/auto-orient/strip|imageView2/2/w/596/format/webp)

上图可看出，如果树为完全二叉树，则节点刚好填满数组。

当二叉树不为完全二叉树时采用顺序存储：

![img](https://upload-images.jianshu.io/upload_images/7043118-92d8a8d61c2aace7.png?imageMogr2/auto-orient/strip|imageView2/2/w/440/format/webp)

其中浅色的节点为不存在，上图的存储如下：

![img](https://upload-images.jianshu.io/upload_images/7043118-d6cd02856b386d6d.png?imageMogr2/auto-orient/strip|imageView2/2/w/448/format/webp)

^处为空节点存储，现在可以看到，已经出现了空间浪费的情况。

那么对于右斜树这种极端情况的存储是什么情形呢？

![img](https://upload-images.jianshu.io/upload_images/7043118-0ada42b04e0861a8.png?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

**二叉链表存储：**

既然顺序存储不能满足二叉树的所有存储形式，那么可以采用链式存储。

由二叉树的定义可知，二叉树的节点最多有两个子节点，所以每个节点的数据结构可以定义为一个数据域和两个指针域：

![img](https://upload-images.jianshu.io/upload_images/7043118-95cd18e8cc20316e.png?imageMogr2/auto-orient/strip|imageView2/2/w/315/format/webp)

定义节点代码：

~~~c
typedef struct BiTNode{
    TElemType data;//数据
    struct BiTNode *lchild, *rchild;//左右孩子指针
} BiTNode, *BiTree;
~~~

![img](https://upload-images.jianshu.io/upload_images/7043118-73ae201506a7adc9.png?imageMogr2/auto-orient/strip|imageView2/2/w/688/format/webp)

上图采用链表形式存储二叉树，这种链表称为二叉链表。

**二叉树的遍历：**

定义：

- 从根节点触发，按某种次序依次访问二叉树中的所有节点，使得每个节点都被访问依次，且仅被访问一次。

二叉树访问次序可以分为4种：

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

**前序遍历：**

根-->左-->右

![img](https://upload-images.jianshu.io/upload_images/7043118-df454c0a574836de.png?imageMogr2/auto-orient/strip|imageView2/2/w/441/format/webp)

前序遍历结果：ABDHIEJCFG

 **中序遍历：**

左-->根-->右

中序遍历结果：HDIBJEAFCG

**后序遍历：**

左-->右-->根

后序遍历结果：HIDJEBFGCA

虽然二叉树的遍历过程看似繁琐，但由于二叉树是一种递归定义的结构，所以使用递归的方式遍历二叉树的代码十分简单：

~~~c++
/*二叉树的前序遍历算法*/
void PreOrderTraverse(BiTree T) {
    if(T == NULL)
        return;
    printf("%c",T->data);/*显示数据*/
    PreOrderTraverse(T->lChild);
    PreOrderTraverse(T->rChild);
}

/*二叉树的中序遍历算法*/
void InOrderTraverse(BiTree T) {
    if(T == NULL)
        return;
    InOrderTraverse(T->lChild);
    printf("%c",T->data);/*显示数据*/
    InOrderTraverse(T->rChild);
}

/*二叉树的后序遍历算法*/
void PostOrderTraverse(BiTree T) {
    if(T == NULL)
        return;
    PostOrderTraverse(T->lChild);
    PostOrderTraverse(T->rChild);
    printf("%c",T->data);/*显示数据*/
}
~~~

**层次遍历：**

层次遍历就是按树的层次自上而下遍历二叉树，

层次遍历结果：ABCDEFGHIJK

二叉树常考考点：

已知前序遍历和中序遍历，求二叉树

已知中序遍历和后序遍历，求二叉树

但是已知前序遍历和后序遍历，不可唯一确定一棵二叉树



#### 二叉查找树 √

又称**二叉搜索树**，亦称**二叉排序树**。

**设x为二叉排序树中的一个节点，则x的左孩子节点一定小于等于x节点，x的右孩子节点一定大于等于x节点。**

**性质：**

- 若左子树不空，则左子树中所有节点的值一定小于根节点的值
- 若右子树不空，则右子树中所有节点的值一定大于根节点的值
- 左子树与右子树也均为二叉查找树

如：

![图2.2.1](https://images.xiaozhuanlan.com/photo/2019/b6127a1a685f51775370658146bcdd82.png)

**节点结构：**

![img](https://images.xiaozhuanlan.com/photo/2019/935a76056b93ad4b620c01be0cf31311.png)

**创建二叉搜索树：**

现有序列：A = {61, 87, 59, 47, 35, 73, 51, 98, 37, 93}。根据此序列构造二叉搜索树过程如下：

  （1）i = 0，A[0] = 61，节点61作为根节点；
  （2）i = 1，A[1] = 87，87 > 61，且节点61右孩子为空，故81为61节点的右孩子；
  （3）i = 2，A[2] = 59，59 < 61，且节点61左孩子为空，故59为61节点的左孩子；
  （4）i = 3，A[3] = 47，47 < 59，且节点59左孩子为空，故47为59节点的左孩子；
  （5）i = 4，A[4] = 35，35 < 47，且节点47左孩子为空，故35为47节点的左孩子；
  （6）i = 5，A[5] = 73，73 < 87，且节点87左孩子为空，故73为87节点的左孩子；
  （7）i = 6，A[6] = 51，47 < 51，且节点47右孩子为空，故51为47节点的右孩子；
  （8）i = 7，A[7] = 98，98 < 87，且节点87右孩子为空，故98为87节点的右孩子；
  （9）i = 8，A[8] = 93，93 < 98，且节点98左孩子为空，故93为98节点的左孩子；创建完毕后如图2.4中的二叉搜索树：

![图2.4](https://images.xiaozhuanlan.com/photo/2019/345efd0ae02be18cbc25b92c518d156b.png)

**查找：**

- 若树是空的，则查找结束，无匹配
- 若当前节点等于要查找的节点值，则查找成功
- 若要查找的值大于当前节点的值，则递归查找右子树
- 若要查找的值小于当前节点的值，则递归查找左子树

**代码：**

~~~js
//递归的方式查找
function searchTree（Node, data）{//Node为当前查找的节点，data为要查找的数据
    if(Node == null)
        return false;
    if(Node.data == data)
        return true;
    if(data > Node.data)
        serarchTree(Node.rChild,data)
    if(data < Node.data)
        searchTree(Node.lChild,data)
}
~~~

平均时间复杂度为O(log2n)

**插入节点：**

图解：

![img](https://images.xiaozhuanlan.com/photo/2019/3f7bd1b7062cbbffecc5bcf38ef020ab.png)

![img](https://images.xiaozhuanlan.com/photo/2019/a83dc468dc9598784a68cbf33f4a9b20.png)

![img](https://images.xiaozhuanlan.com/photo/2019/3717a705b9dfe0a39f7553937195e209.png)

**代码实现：**

~~~js
class Node{
    constructor(data) {
		this.data = data;
        this.lChild = null;
        this.rChile = null;
    }
}

function insertNode(treeNode, data) {
    if(data == treeNode.data) return false;//如果相等则表示存在此节点，无需添加
    if(data > treeNode.data) {
        if(treeNode.rChild == null) {
            let node = new Node(data);
            treeNode.rChild = node;
            return true;
        } else {
            insertNode(treeNode.rChild.data)
        }
    } else {
        if(treeNode.lChild == null) {
            let nodenew Node(data);
            treeNode.lChild = node;
            return true;
        } else {
            insertNode(treeNode.lChild,data)
        }
    }
}
~~~

**删除节点：**

- 若该节点为叶子结点，则直接删除即可
- 若该节点有左右子树，则找到左子树中最小的节点或右子树中最大的节点替换掉要删除的节点

代码：

~~~js

function delTreeNode(TreeNode, data) {
    let TreeNode = findTreeNode(Tree,data);//查找节点并返回
    if(TreeNode == null) return false;//没有该节点，无法删除
    let replaceNode = null;//替换删除节点的节点
    if(TreeNode.lChild != null) {
        let node = TreeNode.lChild;
        while(node.rChild != null) {
            node = node.rChild;
        }
		replaceNode = node.rChild;
        node.rChild = null;
    } else if(TreeNode.rChild != null) {
        let node = TreeNode.rChild;
        while(node.lChild != null) {
            node = node.lChild;
        }
        replaceNode = node.lChild;
        node.lChild = null;
    } else {
        TreeNode = null;
    }
    //交接工作
    replaceNode.lChild = TreeNode.lChild;
    replaceNode.rChild = TreeNode.rChild;
    //换人
    TreeNode = replaceNode;
    return true;//删除成功
}
~~~



#### 平衡二叉树

二叉搜索树一定程度上可以提高搜索效率，但当原序列有序，例如序列A={1,2,3,4,5,6},构造二叉搜索树如下图所示，依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为O(n)。

![图3.1](https://images.xiaozhuanlan.com/photo/2019/c23f52a549d1bc70dc64e7a901ebdd24.png)

在这个图中查找6需要查找6次。二叉查找树的效率取决于树的高度，因此保证树的高度最小，即可保证查找效率。同样的序列A，按照下图的方式存储，查找6只需查找3次，效率提升了一倍！

![img](https://images.xiaozhuanlan.com/photo/2019/72686dbdfe520a06d5ff6fc133b76810.png)

可以看出，当树的节点数目一定时，保持左右两端平衡，树的查找效率最高。

这种左右子树高度不相差1的树为平衡树。

非平衡二叉树

![非平衡二叉树](https://images.xiaozhuanlan.com/photo/2019/82f2367ec04e1ee753eeb5dece1edf1c.png)

平衡二叉树；

![平衡二叉树](https://images.xiaozhuanlan.com/photo/2019/f2d26b71e2ff26f79c4b7ccf0116a20c.png)

**平衡因子：**





#### 平衡二叉查找树

##### ALV树

##### 红黑树

 https://www.jianshu.com/p/e136ec79235c 

#### 完全二叉树

### 多路查找树

#### B树

#### B+树

#### 2-3树

#### 2-3-4树

### 堆

#### 小顶堆

#### 大顶堆

#### 二项堆

#### 优先队列

#### 斐波那契堆