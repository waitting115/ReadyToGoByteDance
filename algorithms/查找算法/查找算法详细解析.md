# 查找算法

## 顺序查找

**介绍：**

​	顺序查找属于**无序查找**算法。

**时间复杂度分析：**

​	O(n)

**代码实现：**

~~~js
function orderFind(arr, n) {
    let len = arr.length;
    for(let i = 0; i < len; i ++) {
        if(arr[i] == n) {
            return i;
        }
    }
    return -1;
}
~~~

**适用范围：**

适用于存储结构为顺序存储或链接存储的线性表。

## 分块查找

又称索引顺序查找，它是顺序查找的一种改进方法。

**算法思想：**

将数据划分为m块儿（类似于桶排序的思想），每块中的节点不必有序，但块与块之间必须“按块有序”，即第一块中任意元素都必须小于第二块儿中任意元素。然后找到每一块中的最大值，把最大值放一个数组中，用二分查找或者顺序查找，找到精确的哪一块，然后在已确定的块中用顺序法进行查找。

## 二分查找

**介绍：**

也称折半查找，属于**有序的查找算法**。

前提是元素必须是有序的。

**时间复杂度分析：**

​	O(logn)

**代码实现：**

~~~js
let arr = [1,2,3,4,5,6,7,8,9], n = 5;
function BinarySearch (arr, n) {
    let len = arr.length, low, high, mid; 
    for(let i = 0; i < len; i ++) {
        low = 0, high = len - 1;
        while(low < high) {
            mid = parseInt((low + high) / 2);
            if(arr[mid] == n) {
                return mid;
            } else if(arr[mid] > n) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
console.log(BinarySearch(arr,n));
~~~

**适用范围：**

适用于有序的静态查找表的查找；

对于需要频繁执行插入和删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。	——《大话数据结构》

## 差值查找（  ！）

**情景带入：:happy:**

是否有这样一种情况，如果数组是从1到100的100个数字，让你查找5，那么人为的思想肯定是从前往后找。如果用二分法查找呢？50,25,12,6,3,4,5这样一个顺序来找，是不是就有点憨憨，哈哈哈​ :happy:

**介绍：**

二分法查找点的计算：

mid = low + 1/2 * (hide -  low);

通过类比，我们可以查找的点改进如下：

**mid = low + (n - arr[low]) / (arr[high] - arr[low]) * (high - low);(这里不理解)**

也就是将上述的1/2改为字适应的值，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近要查找的数值n，这样也就间接的减少了查找次数。

**时间复杂度分析：**

查找成功或者失败的时间复杂度均为**O(loglogn)**。

**代码实现：**

~~~js
let arr = [1,3,4,6,7,9,11,13,14,15,16];
let n = 2;
function interpolationFind(arr, n) {
    let time = 0;
    let low, high, mid, len = arr.length;
    low = 0, high = len - 1;
    while(low < high) {
        console.log('比较次数：', ++ time);
        //这里的parseInt只能放这个位置，放其他位置会导致出错，亲测！
        mid = low + parseInt((n - arr[low]) / (arr[high] - arr[low]) * (high - low));
        console.log(mid);2
        // mid = low + parseInt((high - low) / 2);
        if(arr[mid] == n) {
            return mid;
        } else if (arr[mid] > n) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}

console.log('n的位置：', interpolationFind(arr, n));
~~~

**适用范围：**

对于表长较大，数据分布比较均匀的查找表来说，差值查找比二分查找性能要好的多。

反之，如果数组数据分布非常不均匀，那么差值查找未必是个合适的选择。

## 斐波那契查找（ ！）

## 散列表查找

**介绍：**



**时间复杂度分析：**



**代码实现：**



**适用范围：**



## 树表查找

### 二叉树查找算法

**介绍：**

先对需要排序的数据进行生成树，确保树左分支的值小于右分支的值，然后进行查找。

这种算法的查找效率很高，但是要先创建树。



**二叉查找树**（又称二叉搜索树、二叉排序树）的性质：

- 若其左子树不空，则数值小于根节点值
- 若其右子树不空，则数值大于根节点值
- 任意节点的左右子也为二叉查找树

**对齐进行中序遍历（或叫中根遍历），即可得到有序序列。**

拓展：

- 先序遍历：根-->左-->右
- 中序遍历：左-->根-->右
- 后序遍历：左-->右-->根

**时间复杂度分析：**

它和二分查找一样，插入和查找的时间复杂度均为**O(logn)**，**但在最坏的情况下仍然有O(n)的时间复杂度**，原因在于插入和删除元素的时候树并没有保持平衡，比如在下图中查找17，我们就需要进行n次操作（因为此树并不平衡）。

我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

![img](https://pic1.zhimg.com/80/v2-f28b193d1589c4cfb184d48fb2080058_hd.jpg)

### 2-3查找树

直接上图，简单明了：

![img](https://pic1.zhimg.com/80/v2-6ccac7896663c7720586999426e1dcd8_hd.jpg)

这就是2-3查找树。

**性质：**

- 如果中序遍历2-3查找树，则可以得到有序序列；
- 在一个完全平衡的2-3查找树找那个，根节点到每一个为空的节点的举例都相同。（这也是平衡树中“平衡”的概念。

**复杂度分析：**

2-3查找树的查找效率与树的高度是息息相关的。

- 最坏的情况下，也就是所有的节点都是2-node节点，查找效率为log2n
- 最好的情况下，也就是所有的节点都是3-node节点，查找效率为log3n，约等于0.631log2n.

### 红黑树

它是一种简单实现2-3树的数据结构。

红黑树具体内容参见树篇

### B树和B+树

同上，在树篇会有深入的讲解。

### 树表查找总结：

二叉查找树平均性能不错，为O(logn)，但最坏的情况下会退化为O(n)。

在二叉查找树的基础上进行优化，我们可以使用平衡查找树。

平衡查找树的2-3查找树，这种数据结构在插入图之后能够进行自平衡处理，从而保证了树的高度在一定的范围内，最坏的情况的时间复杂度也有了保证。

但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，它巧妙地使用颜色标记来替代2-3树种比较难处理的3-node节点问题。

**红黑树是一种比较高效的平衡查找树，应用非常广泛**，很多编程语言的内部实现都或多或少的采用了红黑树。

除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。

## 哈希查找



