## 字符串匹配

字符串匹配问题的形式定义：

- **文本（Text）**是一个长度为 n 的数组 T[1..n]；
- **模式（Pattern）**是一个长度为 m 且 m≤n 的数组 P[1..m]；
- T 和 P 中的元素都属于有限的**字母表 Σ 表**；
- 如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个**有效位移（Valid Shift）**。

![img](https://images0.cnblogs.com/blog/175043/201410/032208464871566.png)

比如上图中，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3 处，位移 s = 3 是有效位移。

### 暴力匹配

是最常想到的，也是最好实现的，所以在简单情况下可以直接使用。

首先从原字符串最左端开始匹配子字符串，如果第一个字符与子字符串匹配，则继续看第二个字符与子字符串第二个字符是否匹配。。。如果不匹配，则找原字符串下一位与子字符串第一位相匹配，以此类推

~~~js
let arr = 'hello world';
		let sunArr = 'or';
		function matchingStr (arr, sunArr) {
			for(let i = 0; i < arr.length - sunArr.length + 1; i ++) {
			//如任意个长度的查找3个长度的子串，大字符串的最后3-1个长度没必要比的
				let j = 0;//用来判断查找的长度
				while(j < sunArr.length) {//只要查找长度不大于子串长度就可以继续比
					if(arr[i + j] != sunArr[j]) break;//循环的过程中只要有一个字符不符合，就退出
					j ++;//下一位
				}
				if(j == sunArr.length) return i;//完全符合
			}
			reutrn -1;
		}
		console.log(matchingStr(arr,sunArr));
~~~



### BM



### KMP



### Trid