

## 基本算法思想 √

### 动态规划 √

**我们先考虑能否把大问题分解成小问题，分解的问题也存在最优解，如果把小问题的最优解组合起来能否使整个问题的最优解，这就是动态规划的最优解。**

主要解决的问题：

- 多阶段决策过程的最优化

其主要思想是：将最优化的决策过程分为互相联系的几个阶段，每个阶段需要做出一个决策，并且当前阶段的决策会影响下一阶段的决策，从而影响到整个过程的活动路线。

作为整个过程的最优策略具有这样的性质：

- **无论过去的状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。**

动态规划解题步骤：

1. 正确划分阶段，用阶段变量表示，比如月份，年份等等
2. 正确选择状态变量xk，  使它既能描述过程的状态，又要满足无后效性。所谓**无后效性**是指：如果某段状态给定，则在这段以后过程的发展不受前面各阶段状态的影响。 
3. **确定决策变量uk及每段的允许决策集合。**
4. **写出状态转移方程**，表示由k段到k+1段的整体转移规律，第k段的状态和决策确定，则第k+1段的状态也应该确定下来。
5. **确定指标函数和递推关系式**，它是定义在全过程和所有后部子过程上的数量函数。



**经典例题：**

**最优路线问题：**

 给出一个线路网络， 从A点要铺设一条管道到G点，其两点之间连线上的数字表示两点间的距离；要求选择一条由A到G的铺管线路，使总距离为最短。 

![img](https://img2018.cnblogs.com/blog/1608161/201907/1608161-20190704215615748-1030981036.png)



**爬楼梯问题：**（LeeCode 70）

 	假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。
  每一阶段可以选择1步或者两步，f(n)=f(n-1)+f(n-2)，其实这是一个**斐波那契数列第n项问题**。 

~~~js
var climbStairs = function(n) {
		    //要理解，通往第i个元素的有两个，第i - 1个元素和第i - 2个元素，所以通往第i个元素的方法就是这通往这两个元素的方法之和。（和斐波那契数列一样）
		    if(n < 3) return n;
		    let Fibonacci = [0,1,2];
		    for(let i = 3; i <= n; i ++) {
		        Fibonacci.push(Fibonacci[i - 1] + Fibonacci[i - 2]);
		    }
		    return Fibonacci[n];
		};
		console.log(climbStairs(10))
~~~

**最大子序和**（LeeCode 53）

 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 ![img](https://img2018.cnblogs.com/blog/1608161/201907/1608161-20190704220041732-194371155.png)

~~~js

~~~

**打家劫舍**（LeeCode 198）

 一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
  解答：对于此题，如果只有两家或者以下，我们选择金额最大的。如果2家以上，那我们打劫到第 i 家的时候，就要考虑，要不要打劫这一家，也就是（这一家的价值+打劫到 i - 2家的最大价值）和（打劫到上一家（i - 1）的最大价值），比较这两个值，选较大值作为打劫到第 i 家的最大价值。最后输出最后一家就可以了。
**dp[i] = max(dp[i-2]+nums[i], dp[i-1])** 

~~~js

~~~



### 贪心算法 √

**贪心算法的定义：**

​		贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加以考虑，只做出某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，**选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关**。

**解题的一般步骤：**

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题
- 对每一个子问题局部求解，得到子问题的局部最优解
- 把子问题的局部最优解合成大问题的解

最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是可行的。

贪心算法和动态规划本质上是对子问题树的一种修剪，**两种算法要求问题都具有的一个性质就是子问题最优性(**组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。

**而贪心算法是动态规划方法的一个特例**，**可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况**。**换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。** 



**经典例题：**

1.哈夫曼树：

在森林中，选取两棵权值最小的树组成一棵新树，再在森林中选取两棵权值最小的树组成一棵新树，直到森林中只剩下最后一棵树，即为权值最小的树。

![img](https://upload-images.jianshu.io/upload_images/4889651-e4b93aa07c192a6c)

 2.钱币找零问题
		这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？

​		用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。 



### 回溯算法 √

回溯算法相当于穷举搜索的巧妙实现，对比蛮力的穷举搜索，**回溯算法可以对一些不符合要求或者重复的情况进行裁剪，不再对其进行搜索，以减少搜索提高效率。**

比如图在运用回溯算法的深度优先搜索遍历中，会对已搜索遍历过的顶点进行标记，避免下次回溯搜索中对再次出现的该顶点进行重复遍历。

经典例题：

八皇后问题，在搜索-->深度优先遍历中有提及

### 分治算法 √

**分治算法不是简单的递归，而是将大的问题递归解决较小的问题，然后从子问题的解构建原来问题的解。**

比如快速排序和归并排序都是分治算法，而图的递归深度搜索和二叉树的递归遍历则不是分治算法的应用。

分治算法运行时间的计算有一重要原理：

![img](https://img2018.cnblogs.com/blog/1637843/201906/1637843-20190601211242816-1872276994.png)





### 枚举算法 √

1，枚举算法的定义：
在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么该结论是可靠 的，这种归纳方法叫做枚举法。
2，枚举算法的思想是：
将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，舍弃不合适的。
3，使用枚举算法解题的基本思路如下：
（1）确定枚举对象、范围和判定条件。
（2）逐一枚举可能的解并验证每个解是否是问题的解。
4，枚举算法步骤：
（1）确定解题的可能范围，不能遗漏任何一个真正解，同时避免重复。
（2）判定是否是真正解的方法。
（3）为了提高解决问题的效率，使可能解的范围将至最小，
5，枚举算法的流程图如下所示：
                                       

二，枚举算法实例

例一：百钱买白鸡
1，问题描述：
公鸡每只5元，母鸡每只3元，三只小鸡1元，用100元买100只鸡，问公鸡、母鸡、小鸡各多少只？
2，算法分析：
利用枚举法解决该问题，以三种鸡的个数为枚举对象,分别设为mj,gj和xj，用三种鸡的总数 （mj+gj+xj=100）和买鸡钱的总数（1/3*xj+mj*3+gj*5=100）作为判定条件，穷举各种鸡的个数。

