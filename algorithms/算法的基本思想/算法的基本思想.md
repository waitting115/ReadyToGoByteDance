## 基本算法思想

### 动态规划

**我们先考虑能否把大问题分解成小问题，分解的问题也存在最优解，如果把小问题的最优解组合起来能否使整个问题的最优解，这就是动态规划的最优解。**

主要解决的问题：

- 多阶段决策过程的最优化

其主要思想是：将最优化的决策过程分为互相联系的几个阶段，每个阶段需要做出一个决策，并且当前阶段的决策会影响下一阶段的决策，从而影响到整个过程的活动路线。

作为整个过程的最优策略具有这样的性质：

- 无论过去的状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。

动态规划解题步骤：

1. 正确划分阶段，用阶段变量表示，比如月份，年份等等
2. 正确选择状态变量xk，  使它既能描述过程的状态，又要满足无后效性。所谓**无后效性**是指：如果某段状态给定，则在这段以后过程的发展不受前面各阶段状态的影响。 
3. **确定决策变量uk及每段的允许决策集合。**
4. **写出状态转移方程**，表示由k段到k+1段的整体转移规律，第k段的状态和决策确定，则第k+1段的状态也应该确定下来。
5. **确定指标函数和递推关系式**，它是定义在全过程和所有后部子过程上的数量函数。



**经典例题：**

**最优路线问题：**

 给出一个线路网络， 从A点要铺设一条管道到G点，其两点之间连线上的数字表示两点间的距离；要求选择一条由A到G的铺管线路，使总距离为最短。 

![img](https://img2018.cnblogs.com/blog/1608161/201907/1608161-20190704215615748-1030981036.png)



**爬楼梯问题：**（LeeCode 70）

 	假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。
  每一阶段可以选择1步或者两步，f(n)=f(n-1)+f(n-2)，其实这是一个**斐波那契数列第n项问题**。 

~~~js
var climbStairs = function(n) {
		    //要理解，通往第i个元素的有两个，第i - 1个元素和第i - 2个元素，所以通往第i个元素的方法就是这通往这两个元素的方法之和。（和斐波那契数列一样）
		    if(n < 3) return n;
		    let Fibonacci = [0,1,2];
		    for(let i = 3; i <= n; i ++) {
		        Fibonacci.push(Fibonacci[i - 1] + Fibonacci[i - 2]);
		    }
		    return Fibonacci[n];
		};
		console.log(climbStairs(10))
~~~

**最大子序和**（LeeCode 53）

 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 ![img](https://img2018.cnblogs.com/blog/1608161/201907/1608161-20190704220041732-194371155.png)

~~~js

~~~

**打家劫舍**（LeeCode 198）

 一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
  解答：对于此题，如果只有两家或者以下，我们选择金额最大的。如果2家以上，那我们打劫到第 i 家的时候，就要考虑，要不要打劫这一家，也就是（这一家的价值+打劫到 i - 2家的最大价值）和（打劫到上一家（i - 1）的最大价值），比较这两个值，选较大值作为打劫到第 i 家的最大价值。最后输出最后一家就可以了。
**dp[i] = max(dp[i-2]+nums[i], dp[i-1])** 

~~~js

~~~



### 贪心算法

贪心算法的定义：

​		贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说不从整体最优上加一考虑，只做出某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

解题的一般步骤：

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题
- 



### 回溯算法

### 分治算法

### 枚举算法

