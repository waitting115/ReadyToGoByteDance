## 字符串匹配

字符串匹配问题的形式定义：

- **文本（Text）**是一个长度为 n 的数组 T[1..n]；
- **模式（Pattern）**是一个长度为 m 且 m≤n 的数组 P[1..m]；
- T 和 P 中的元素都属于有限的**字母表 Σ 表**；
- 如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个**有效位移（Valid Shift）**。

![img](https://images0.cnblogs.com/blog/175043/201410/032208464871566.png)

比如上图中，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3 处，位移 s = 3 是有效位移。

### BF算法 （暴力匹配） √

也叫朴素的字符串匹配算法。

是最常想到的，也是最好实现的，所以在简单情况下可以直接使用。

首先从原字符串最左端开始匹配子字符串，如果第一个字符与子字符串匹配，则继续看第二个字符与子字符串第二个字符是否匹配。。。如果不匹配，则找原字符串下一位与子字符串第一位相匹配，以此类推

~~~js
let arr = 'hello world';
		let sunArr = 'or';
		function matchingStr (arr, sunArr) {
			for(let i = 0; i < arr.length - sunArr.length + 1; i ++) {
			//如任意个长度的查找3个长度的子串，大字符串的最后3-1个长度没必要比的
				let j = 0;//用来判断查找的长度
				while(j < sunArr.length) {//只要查找长度不大于子串长度就可以继续比
					if(arr[i + j] != sunArr[j]) break;//循环的过程中只要有一个字符不符合，就退出
					j ++;//下一位
				}
				if(j == sunArr.length) return i;//完全符合
			}
			reutrn -1;
		}
		console.log(matchingStr(arr,sunArr));
~~~

其实一个循环就可以解决：

~~~js
function matchingAtr(arr, sunArr) {
			let i = 0, j = 0;//i表示arr匹配的元素位置，j为sunArr匹配的元素位置
			while(i < arr.length && j < sunArr.length) {
				if(arr[i] == sunArr[j]) {
					i ++;
					j ++;
				} else {
					i = i - j + 1;//因为要下一位，所以+1
					j = 0;
				}
			}
			if(j == sunArr.length) {
				return i - j;
			} else {
				return -1;
			}
		}
		console.log(matchingAtr('hello world', 'rld'));
~~~



### KMP算法

下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。

1.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png)

首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。

2.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png)

因为B与A不匹配，搜索词再往后移。

3.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png)

就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。

4.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png)

接着比较字符串和搜索词的下一个字符，还是相同。

5.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)

直到字符串有一个字符，与搜索词对应的字符不相同为止。

6.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png)

这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍。

7.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)

一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。

8.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)

怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。

9.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)

已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：

> 　　移动位数 = 已匹配的字符数 - 对应的部分匹配值

因为 6 - 2 等于4，所以将搜索词向后移动4位。

10.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png)

因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。

11.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png)

因为空格与A不匹配，继续后移一位。

12.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png)

逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。

13.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png)

逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。

14.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050114.png)

下面介绍《部分匹配表》是如何产生的。

首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

15.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以"ABCDABD"为例，

> 　　－　"A"的前缀和后缀都为空集，共有元素的长度为0；
>
> 　　－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
>
> 　　－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
>
> 　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
>
> 　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
>
> 　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
>
> 　　－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

自己的看法：

其实这样实现起来个人觉得会很吃力，我倒有一个简易一点的算法：

- 新建一个“部分匹配值”数组pmv = [] （partial matching value）；

- 从第二个元素开始for遍历搜索词，看是否与第一个元素相等，如果不相等，则将pmv的此位置设为0，i++进入下一for循环；如果二者相等，则进入一个while循环，先将pmv的此位置值设为1，然后比较当前位置的下一位是否与第二位相等，如果相等则将pmv的此位置设为2，直到不相等，退出while循环，继续for循环。    for循环完成后将pmv返回即为所求！

~~~js
function computePMV(str) {
			let pmv = [0];
			for(let i = 1; i < str.length;) {
				let j = 0, time = 1;
				if(str[i] != str[j]) {
					pmv[i] = 0;
					i ++;
				} else {
					while(str[i] == str[j]) {
						pmv[i] = time;
						i ++;
						j ++;
						time ++;
					}
				}
			}
			return pmv;
		}
		console.log(computePMV('abcdabd'));
~~~

16.

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png)

**"部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置。**

**KMP算法的时间复杂度为：O(m+n)**

实现KMP算法：

~~~js
//求next[]
function computePMV(str) {
    let pmv = [0];
    for(let i = 1; i < str.length;) {
        let j = 0, time = 1;
        if(str[i] != str[j]) {
            pmv[i] = 0;
            i ++;
        } else {
            while(str[i] == str[j]) {
                pmv[i] = time;
                i ++;
                j ++;
                time ++;
            }
        }
    }
    return pmv;
}
let bigArr = 'bbc abcdab abcdabcdabde'
let smallArr = 'abcdabd';
function KMP(bigArr,smallArr) {
    let next = computePMV(smallArr);
    for(let i = 0, j = 0; i < bigArr.length; ) {
        if(bigArr[i] != smallArr[j] && j == 0) i ++;//j不等于0的时候i不能动
        while(bigArr[i] == smallArr[j]) {//如果元素相等则开始while循环判断后续
            i ++;
            j ++;
        }
        if(j == smallArr.length) return i - j;
        if(j != 0) j = next[j - 1];
    }
    return -1;
}
console.log(KMP(bigArr, smallArr));
~~~



### BM算法



### Trid